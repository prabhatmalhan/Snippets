{
	"cpp program": {
		"prefix": "cppro",
		"body": [
			"#include<bits/stdc++.h>",
			"$1",
			"#define ll long long",
			"#define vi vector <int>",
			"using namespace std;",
			"\n",
			"int main($2)",
			"{",
			"\t$3",
			"\treturn 0;",
			"}"
		],
		"description": "basic c++ program"
	},
	"Printing a map": {
		"prefix": "prma",
		"body": [
			"for(auto x: m)",
			"\tcout<<x.first<<$1<<x.second<<endl;"
		],
		"description": "printing a map"
	},
	"competetive cpp program": {
		"prefix": "ccppro",
		"body": [
			"#include<bits/stdc++.h>",
			"$1",
			"#define mod 1000000007",
			"#define INF 2147483637",
			"#define vi vector <int>",
			"#define ll long long",
			"using namespace std;",
			"",
			"int main($2)",
			"{",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tint no=1;",
			"\tcin>>no;",
			"\tfor (int f = 0; f < no; f++)",
			"\t{",
			"\t\t$3",
			"\t}",
			"\t$4",
			"\treturn 0;",
			"}"
		],
		"description": "Competetive c++ program"
	},
	"include": {
		"prefix": "inc",
		"body": [
			"#include <$1>"
		],
		"description": "include header file"
	},
	"online judge": {
		"prefix": "onj",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"\tfreopen(\"${1:input.txt}\",\"r\",stdin);",
			"\tfreopen(\"${2:output.txt}\",\"w\",stdout);",
			"#endif"
		],
		"description": "define input and output file as I/O"
	},
	"for loop": {
		"prefix": "forl",
		"body": [
			"for(int ${1:i}=${2:0} ; $1<${3:n} ; ++$1)",
			"{",
			"\t$4",
			"}"
		],
		"description": "for loop"
	},
	"Count Frequency and save in map": {
		"prefix": "frem",
		"body": [
			"map<int, int> m;",
			"for (int i = 0; i < n; i++)",
			"{",
			"    if (m.find(arr[i]) == m.end())",
			"    {",
			"        m[arr[i]] = 1;",
			"    }",
			"    else",
			"    {",
			"        m[arr[i]]++;",
			"    }",
			"}"
		],
		"description": "frequency count"
	},
	"reverse for loop": {
		"prefix": "rforl",
		"body": [
			"for(int ${1:i}=${2:n} ; $1>${3:0} ; --$1)",
			"{",
			"\t$4",
			"}"
		],
		"description": "reverse for loop"
	},
	"input array": {
		"prefix": "inarr",
		"body": [
			"int ${1:arr}[${2:n}];",
			"for(int i=0 ; i<${2:n} ; ++i)",
			"\tcin>>${1:arr}[i];"
		],
		"description": "input array"
	},
	"input 2-D array": {
		"prefix": "inarr2",
		"body": [
			"int ${1:arr}[${2:m}][${3:n}];",
			"for(int i=0 ; i<${2:m} ; ++i)",
			"\tfor(int j=0 ; j<${3:n} ; ++j)",
			"\t\tcin>>${1:arr}[i][j];"
		],
		"description": "input 2-d array"
	},
	"input vector": {
		"prefix": "invec",
		"body": [
			"vi ${1:arr}(${2:n});",
			"for(int i=0 ; i<${2:n} ; ++i)",
			"\tcin>>${1:arr}[i];"
		],
		"description": "input array"
	},
	"Sort Line": {
		"prefix": "so",
		"body": [
			"sort(arr,arr+n);"
		],
		"description": "line for sort"
	},
	"vector Decleration": {
		"prefix": "vi",
		"body": [
			"vector <int> v"
		],
		"description": "line for vector"
	},
	"Sort With Index Tracked": {
		"prefix": "soin",
		"body": [
			"sort(ind, ind + n, [&](int i, int j){ return arr[i] < arr[j]; });",
			"sort(arr, arr + n);"
		],
		"description": "line for sorting with indexes in track"
	},
	"Prefix sum array": {
		"prefix": "pref",
		"body": [
			"int psa[n+1];",
			"psa[0]=0;",
			"for (int i = 0; i < n; i++)",
			"{",
			"\tpsa[i+1] = psa[i] + arr[i];",
			"}"
		],
		"description": "prefix sum of array"
	},
	"Printf precise": {
		"prefix": "pr",
		"body": [
			"cout<<$1${2:<<endl};"
		],
		"description": "print statement"
	},
	"print array": {
		"prefix": "prarr",
		"body": [
			"for(int i=0 ; i<${1:n} ; ++i)",
			"\tcout<<${2:arr}[i]<<${3:endl};"
		],
		"description": "print array"
	},
	"print 2-D array": {
		"prefix": "prarr2",
		"body": [
			"for(int i=0 ; i<${1:n} ; ++i)",
			"\tfor(int j=0 ; j<${2:n} ; ++j)",
			"\t\tcout<<${3:arr}[i][j]${4:<<endl};"
		],
		"description": "print 2-d array"
	},
	"print vector": {
		"prefix": "prvec",
		"body": [
			"for(int i=0 ; i<v.size() ; ++i)",
			"    cout<<v[i]<<${1:endl};"
		],
		"description": "print array"
	},
	"sort array": {
		"prefix": "compsrt",
		"body": [
			"for(int i=0;i<${1:n}-1;++i)",
			"{",
			"    sm = i;",
			"    for(int j=i+1 ; j<$1 ; ++j)",
			"    \tif(${2:arr}[sm]>$2[j])",
			"    \t\tsm = j;",
			"    int temp = $2[sm];",
			"    $2[sm]=$2[i];",
			"    $2[i]=temp;",
			"}"
		],
		"description": "sort array"
	},
	"linear search": {
		"prefix": "lsearch",
		"body": [
			"for(int i=0;i<${1:n};++i)",
			"{",
			"\tif(${2:arr}[i] == ind)",
			"\t{",
			"\t\t$3",
			"\t}",
			"}",
			""
		],
		"description": "linear search"
	},
	"binary search": {
		"prefix": "bsearch",
		"body": [
			"int b=${1:0},e=${2:n}-1;",
			"while(b<=e)",
			"{",
			"\tint mid=(b+e)/2;",
			"\tif(${3:arr}[mid] == ${4:k})",
			"\t{",
			"\t\t$5",
			"\t}",
			"\telse if($3[mid] < $4)",
			"\t{",
			"\t\t$6",
			"\t}",
			"\telse",
			"\t{",
			"\t\t$7",
			"\t}",
			"}"
		],
		"description": "binary search"
	},
	"trenary operator": {
		"prefix": "ter",
		"body": [
			"$1?$2:$3"
		],
		"description": "ternary operator"
	},
	"while loop": {
		"prefix": "whilel",
		"body": [
			"while(${1:n})",
			"{",
			"\t$2",
			"\t--$1;",
			"}"
		],
		"description": "while loop"
	},
	"do - while loop": {
		"prefix": "dowl",
		"body": [
			"do",
			"{",
			"\t$1",
			"\t--$2;",
			"}while(${2:n});"
		],
		"description": "do - while loop"
	},
	"switch case": {
		"prefix": "sw",
		"body": [
			"switch($1)",
			"{",
			"\tcase $2:$3",
			"\t\t  break;",
			"\t$4",
			"\tdefault:$5",
			"}"
		],
		"description": "switch case"
	},
	"input": {
		"prefix": "in",
		"body": [
			"${1:int} ${2:n};",
			"cin>>$2;"
		],
		"description": "input"
	},
	"function defination": {
		"prefix": "fun",
		"body": [
			"${1:void} ${2:fun}($3)",
			"{",
			"\t$4",
			"\t${5:return ${6}};",
			"}"
		],
		"description": "function defination"
	},
	"recursive function defination": {
		"prefix": "rfun",
		"body": [
			"${1:void} ${2:fun}($3)",
			"{",
			"\tif($4)",
			"\t\treturn $5;",
			"\telse",
			"\t{",
			"\t\t$6",
			"\t\t${7:return ${8}$2($9)};",
			"\t}",
			"}"
		],
		"description": "recursive function defination"
	},
	"structure defintation": {
		"prefix": "stru",
		"body": [
			"struct $1",
			"{",
			"\t$2",
			"}$3;"
		],
		"description": "structure defintation"
	},
	"file defination": {
		"prefix": "filopn",
		"body": [
			"File *${1:f};",
			"$1 = fopen(\"$2\",\"${3:a+}\");",
			"if($1 == NULL)",
			"{",
			"\tputs(\"Unable to open file\");",
			"\texit(1);",
			"}"
		],
		"description": "file defination"
	},
	"malloc": {
		"prefix": "mal",
		"body": [
			"${1:int} *${2:p};",
			"$2 = ($1*)malloc(${3:n}*sizeof($1));"
		],
		"description": "malloc"
	},
	"Class Defination": {
		"prefix": "cla",
		"body": [
			"class $1",
			"{",
			"\t$2",
			"\t${3:private:}",
			"\t$4",
			"\t${5:public:}",
			"\t$6",
			"};"
		],
		"description": "Class Defination"
	},
	"Factorial Function Defination": {
		"prefix": "fct",
		"body": [
			"unordered_map<ll int,ll int> dp;",
			"ll fact(ll n)",
			"{",
			"\tif(n == 0) return 1;",
			"\tif(n == 1) return n;",
			"\tif(dp.find(n) != dp.end()) return dp[n];",
			"\treturn dp[n] = n*fact(n-1);",
			"}"
		],
		"description": "Factorial Function"
	},
	"Longest Common Substring": {
		"prefix": "lcs",
		"body": [
			"int dp[s.length()+1][s1.length()+1];",
			"int ans = INT_MIN;",
			"for(int i=0 ; i<=s.length() ; ++i)",
			"{",
			"\tfor(int j=0 ; j<=s1.length() ; ++j)",
			"\t{",
			"\t\tif (i==0 || j==0)",
			"\t\t{",
			"\t\t\tdp[i][j]=0;",
			"\t\t}",
			"\t\telse if (s[i-1] == s1[j-1])",
			"\t\t{",
			"\t\t\tdp[i][j] = dp[i-1][j-1]+1;",
			"\t\t\tans = max(dp[i][j],ans);",
			"\t\t}",
			"\t\telse",
			"\t\t{",
			"\t\t\tdp[i][j]=0;",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "Longest Common Substring"
	},
	"Sum of Digits of a Number": {
		"prefix": "sodg",
		"body": [
			"int getSum(int n)",
			"{",
			"\tint sum = 0;",
			"\twhile (n != 0)",
			"\t{",
			"\t\tsum = sum + n % 10;",
			"\t\tn = n / 10;",
			"\t}",
			"\treturn sum;",
			"}"
		],
		"description": "Sum of Digits of a Number Function"
	},
	"Fibonacci Series": {
		"prefix": "fibo",
		"body": [
			"unordered_map <int, int>dp;",
			"\nint fibonacci(int n)",
			"{",
			"\tint f=0, s=0;",
			"\tif (n<=1)",
			"\t\treturn n;",
			"\tif (dp.find(n-1) != dp.end())",
			"\t\tf = dp[n-1];",
			"\telse",
			"\t\tf = fibonacci(n-1);",
			"\tif (dp.find(n-2) != dp.end())",
			"\t\ts = dp[n-2];",
			"\telse",
			"\t\ts = fibonacci(n-2);",
			"\treturn dp[n] = (f+s);",
			"}"
		],
		"description": "Fibonacci Series uding DP"
	},

	"Stopwatch": {
		"prefix": "sto",
		"body": [
			"double tick()",
			"{",
			"\tstatic clock_t start_time;",
			"\tclock_t end_time = clock();",
			"\tdouble diff = 1.0 * (end_time - start_time) / CLOCKS_PER_SEC;", 
			"\tstart_time = end_ticks;",
			"\treturn diff;",
			"}"
		], 
		"description": "function to return time lapsed wherever called"
  },
  
	"Power Function": {
		"prefix": "mpow",
		"body": [
			"ll newpow(int b, int e, int modu = 1)",
			"{",
			"\tll result = 1, base = b, exp = e;",
			"\tif (modu)",
			"\t\tbase %= mod;",
			"\twhile (exp > 0)",
			"\t{",
			"\t\tif (exp & 1)",
			"\t\t{",
			"\t\t\tresult = ((ll)result * base);",
			"\t\t\tif (modu)",
			"\t\t\t\tresult %= mod;",
			"\t\t}",
			"\t\tbase = ((ll)base * base);",
			"\t\tif (modu)",
			"\t\t\tbase %= mod;",
			"\t\texp >>= 1;",
			"\t}",
			"\treturn result;",
			"}",
		],
		"description": "Power of a number",
	}
}
